<?php


namespace ArtaxApiBuilder;


use Danack\Code\Generator\ClassGenerator;
use Danack\Code\Generator\MethodGenerator;
use Danack\Code\Generator\ParameterGenerator;


/**
 * @param $savePath
 * @throws \RuntimeException
 */
function saveFile($savePath, $fqcn, $text) {

    $filename = str_replace('\\', '/', $fqcn);

    $fileHeader = <<< END
<?php

//Auto-generated by ArtaxServiceBuilder - https://github.com/Danack/ArtaxServiceBuilder
//
//Do not be surprised if any changes to this file are over-written.
//

END;

    $outputFilename = $savePath.'/'.$filename.'.php';
    @mkdir(dirname($outputFilename), 0777, true);
    $written = @file_put_contents($outputFilename, $fileHeader.$text);

    if ($written == false) {
        throw new APIBuilderException("Failed to write file $filename.");
    }
}

function getNamespace($namespaceClass) {

    if (is_object($namespaceClass)) {
        $namespaceClass = get_class($namespaceClass);
    }

    $lastSlashPosition = mb_strrpos($namespaceClass, '\\');

    if ($lastSlashPosition !== false) {
        return mb_substr($namespaceClass, 0, $lastSlashPosition);
    }

    return "";
}


function getClassName($namespaceClass) {
    $lastSlashPosition = mb_strrpos($namespaceClass, '\\');

    if ($lastSlashPosition !== false) {
        return mb_substr($namespaceClass, $lastSlashPosition + 1);
    }

    return $namespaceClass;
}



class APIGenerator {

    /**
     * @var ClassGenerator
     */
    private $generator;
    private $outputPath;
    private $namespace;
    private $parameterTranslations = [];
    private $apiParameters;

    /**
     * Fully qualified classname - aka namespace + classname
     * @var
     */
    private $fqcn;
    
    private $fqExceptionClassname = null;

    /**
     * @var string[] The interfaces the generated API class should implement
     */
    private $interfaces = [];

    private $includeMethods = [];

    /**
     * @var callable
     */
    private $normalizeMethodCallable = null;

    /**
     * @var callable
     */
    private $normalizeClassCallable = null;

    /**
     * @var \BaseReality\ArtaxBuilder\OperationDefinition[]
     */
    private $operations = [];

    /**
     * @param $outputPath
     * @param $constructorParams
     */
    function __construct($outputPath, $constructorParams) {
        $this->generator = new ClassGenerator();
        $this->constructorParams = $constructorParams;
        $this->addConstructorMethod();
        $this->outputPath = $outputPath;
    }

    /**
     * Get the list of parameters (by name) that should only exist at an API level, rather
     * than being copied all over the API.
     * @return mixed
     */
    function getAPIParameters() {
        return $this->apiParameters;
    }

    /**
     * @param $interface
     */
    function addInterface($interface) {
        $this->interfaces[] = $interface;
    }

    /**
     * @param $parameter
     * @return mixed
     */
    function translateParameter($parameter) {
        if (array_key_exists($parameter, $this->parameterTranslations) == true) {
            return $this->parameterTranslations[$parameter];
        }

        return $parameter;
    }


    /**
     * @param $fqcn
     */
    function setFQCN($fqcn) {
        $this->fqcn = $fqcn;
        $this->generator->setFQCN($fqcn);

        if ($this->fqExceptionClassname == null) {
            $this->fqExceptionClassname =  $this->fqcn.'Exception';
        }

        $this->namespace = getNamespace($this->fqcn);
    }

    /**
     * 
     */
    function addConstructorMethod() {
        
        if (count($this->constructorParams)) {
            $methodGenerator = new MethodGenerator('__construct');

            $body = '';
            $params = [];
            foreach ($this->constructorParams as $constructorParam) {
                $param = new ParameterGenerator($constructorParam);
                $params[] = $param;
                
                $body .= sprintf('$this->%s = $%s;', $constructorParam, $constructorParam);

                $body .= PHP_EOL;
            }
            $methodGenerator->setBody($body);
            $methodGenerator->setParameters($params);
            $this->generator->addMethodFromGenerator($methodGenerator);
        }
    }
    

    /**
     *
     */
    function addCallMethod() {
        $methodGenerator = new MethodGenerator('callAPI');
        $successStatusParam = new ParameterGenerator('successStatuses', 'array', []);
        $methodGenerator->setParameters(['url', 'parameters', $successStatusParam]);
        $methodGenerator->setBody($this->getCallBody());
        $this->generator->addMethodFromGenerator($methodGenerator);
    }


    /**
     * @return string
     */
    function getCallBody() {

        $body = <<< 'END'

$client = new \Artax\Client();

$client->setOption('transfertimeout', 25);
$request = new \Artax\Request();
$fullURL = $url.'?'.http_build_query($parameters, '', '&', PHP_QUERY_RFC3986);
$request->setUri($fullURL);

$response = $client->request($request);
$status = $response->getStatus();
$status = intval($status);

if ($successStatuses != null  && in_array($status, $successStatuses)) {
    throw new \%s(
        $response, 
        "Status does not match one of ".implode(', ', $successStatuses)
    );
}
else {
    if ($status < 200 || $status >= 300) {
        throw new \%s(
            $response, 
            "Status $status is not 20x success."
        );
    }
}

return $response;
END;
        $body = sprintf(
            $body,
            $this->fqExceptionClassname,
            $this->fqExceptionClassname
        );

        return $body;
    }


    /**
     * @param $methodName
     * @param $functionDefintion
     */
    function addMethod($methodName, OperationDefinition $operation) {
        $this->operations[$methodName] = $operation;
    }

    /**
     * 
     */
    function generateOperationGetters() {
        foreach ($this->operations as $methodName => $operation) {

            $operationName = $this->normalizeMethodName($methodName);
            $operationClassName = $this->normalizeClassName($methodName);
            $methodGenerator = new MethodGenerator($operationName);
            
            //All required parameters must be passed in when the operation is created.
            $requiredParameters = $operation->getRequiredParams();
            $paramsStrings = [];
            $requiredParamsStringsWithDollar = [];
            foreach($requiredParameters as $requiredParam) {
                $paramsStrings[] = $requiredParam->getName();
                //TODO - replace with array_map on $paramsStrings
                $requiredParamsStringsWithDollar[] = '$'.$requiredParam->getName();
            }

            $paramString = implode(', ', $requiredParamsStringsWithDollar);
            $methodGenerator->setParameters($paramsStrings);

            //Parameters which are set at the API level need to be passed into the
            //operation from the API
            $apiParameters = $this->getAPIParameters();
            foreach ($requiredParameters as $param) {
                if (in_array($param->getName(), $apiParameters) == true) {
                    $paramsStrings[] = $param->getName();
                }
            }

            $body = "\$instance = new $operationClassName($paramString);".PHP_EOL;
            $body .= "\$instance->setAPI(\$this);".PHP_EOL;
            $body .= "return \$instance;".PHP_EOL;

            $methodGenerator->setBody($body);
            $this->generator->addMethodFromGenerator($methodGenerator);
        }
    }

    /**
     * 
     */
    private function generateMethods() {
        foreach ($this->operations as $methodName => $operation) {
            $this->generateOperationClass($methodName, $operation);
        }
    }

    /**
     * @param $methodName
     * @return mixed
     */
    public function normalizeMethodName($methodName) {
        
        if ($this->normalizeMethodCallable != null) {
            $callable = $this->normalizeMethodCallable;
            return $callable($methodName);
        }
        
        return str_replace('.', '_', $methodName);
    }

    /**
     * @param $methodName
     * @return mixed
     */
    public function normalizeClassName($methodName) {
        if ($this->normalizeClassCallable != null) {
            $callable = $this->normalizeClassCallable;
            return $callable($methodName);
        }

        return str_replace('.', '', $methodName);
    }

    /**
     * @param $methodName
     * @param OperationDefinition $operation
     */
    private function generateOperationClass($methodName, OperationDefinition $operation) {
        $className = $this->normalizeClassName($methodName);
        
        $operationGenerator = new OperationGenerator(
            $this->namespace,
            $className,
            $operation,
            $this->outputPath,
            $this
        );

        $operationGenerator->setAPIClassname($this->fqcn);
        
        $operationGenerator->generate();
    }


    /**
     * @throws \Exception
     */
    function sanityCheck() {

        if (!$this->fqcn) {
            throw new APIBuilderException("fqcn is empty, cannot generate API.");
        }

        if (!$this->fqExceptionClassname) {
            throw new APIBuilderException("fqExceptionClassname is empty, cannot generate API.");
        }
    }


    /**
     * @throws \ArtaxApiBuilder\APIBuilderException
     */
    function generateExceptionClass() {
        
        $namespace = getNamespace($this->fqcn);
        $classname = getClassName($this->fqcn);
        $exceptionClassname = $classname.'Exception';

        if ($namespace) {
            $fqExceptionClassname = $namespace.'\\'.$classname;
        }
        else {
            $fqExceptionClassname = $classname;
        }
        

$classText = <<< END
<?php

namespace $namespace;

use Artax\Response;

class $exceptionClassname extends \Exception {

    /**
     * @var \Artax\Response
     */
    private \$response;
    
    function __construct(Response \$response, \$message = "", \$code = 0, \Exception \$previous = null) {
        parent::__construct(\$message, \$code, \$previous);
        \$this->response = \$response;
    }
    
    function getResponse() {
        return \$this->response;
    }
}

END;

        saveFile($this->outputPath, $fqExceptionClassname, $classText);
    }

    /**
     * @param array $methodNameArray
     */
    function includeMethods(array $methodNameArray) {
        $this->includeMethods = array_merge($this->includeMethods, $methodNameArray);
    }

    /**
     * @param $operationName
     * @return bool
     */
    function shouldOperationBeGenerated($operationName) {
        if (in_array($operationName, $this->includeMethods)) {
            return true;
        }

        return false;
    }

    /**
     * Guzzle style service descriptions have a bad habit of requiring certain parameters
     * that ought to be defined once, be defined in every operation that requires them. 
     * For example the Flickr API requires the api_key be set for every operation. It dumb 
     * and counter-productive to define this repeatedly in the API. It should be set once
     * in the API, and that value be passed to every operation that requires it.
     * @param array $apiParameters
     */
    public function addAPIParameters(array $apiParameters) {
        $this->apiParameters = array_merge($this->apiParameters, $apiParameters);
    }


    /**
     * Allows you to use your preference for formatting of variables in the API library
     * code, while still passing the correct variables to the API end-point.
     * 
     * Because other people have no taste.
     * @param array $translations
     */
    public function addParameterTranslation(array $translations) {
        $this->parameterTranslations = array_merge($this->parameterTranslations, $translations);
    }
    

    /**
     * @param $service
     * @param $operationName
     * @param $baseURL
     * @return OperationDefinition
     * @throws \ArtaxApiBuilder\APIBuilderException
     */
    function getOperationDescription($service, $operationName, $baseURL) {

        if (isset($service["operations"][$operationName]) == false) {
            throw new APIBuilderException("Service does not have operation named `$operationName`.");
        }

        $operationDescription = $service["operations"][$operationName];

        if (isset($operationDescription['extends'])) {
            $operation = $this->getOperationDescription($service, $operationDescription['extends'], $baseURL);
        }
        else {
            $operation = new OperationDefinition();
        }

        $operation->setName($operationName);
        $operation->setURL($baseURL);//Do this first, as it can be overwritten
        $operation->setFromServiceDescription($operationDescription);

        return $operation;
    }


    /**
     * @param $serviceFilename
     * @return array
     * @throws APIBuilderException
     */
    function parseAndAddService($serviceFilename) {
        $service = require_once($serviceFilename);

        if ($service == false) {
            throw new APIBuilderException("Failed to open service file `$serviceFilename`.");
        }
        if (is_array($service) == false) {
            throw new APIBuilderException("File `$serviceFilename` did not return a service array. Cannot build API from it.");
        }

        $baseURL = null;

        if (isset($service["baseUrl"])) {
            $baseURL = $service["baseUrl"];
        }

        foreach ($service["operations"] as $operationName => $operationDescription) {
            if ($this->shouldOperationBeGenerated($operationName)) {
                $operation = $this->getOperationDescription($service, $operationName, $baseURL);
                $this->addMethod($operation->getName(), $operation);
            }
        }
    }


    /**
     *
     */
    function generate() {        
        $this->sanityCheck();
        $this->addCallMethod();
        $this->generateMethods();
        $this->generateOperationGetters();

        if (count($this->interfaces)) {
            $this->generator->setImplementedInterfaces($this->interfaces);
        }

        $this->generateExceptionClass();

        $text = $this->generator->generate();
        saveFile($this->outputPath, $this->fqcn, $text);
    }
}