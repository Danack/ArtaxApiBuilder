<?php


namespace ArtaxApiBuilder;


use Danack\Code\Generator\ClassGenerator;
use Danack\Code\Generator\GeneratorInterface;
use Danack\Code\Generator\DocBlockGenerator;
use Danack\Code\Generator\InterfaceGenerator;
use Danack\Code\Generator\MethodGenerator;
use Danack\Code\Generator\ParameterGenerator;

use Danack\Code\Generator\DocBlock\Tag\GenericTag;
use Danack\Code\Generator\PropertyGenerator;

/**
 * @param $savePath
 * @throws \RuntimeException
 */
function saveFile($savePath, $fqcn, $text) {

    $filename = str_replace('\\', '/', $fqcn);

    $fileHeader = <<< END
<?php

//Auto-generated by ArtaxServiceBuilder - https://github.com/Danack/ArtaxServiceBuilder
//
//Do not be surprised if any changes to this file are over-written.
//

END;

    $outputFilename = $savePath.'/'.$filename.'.php';
    @mkdir(dirname($outputFilename), 0777, true);
    $written = @file_put_contents($outputFilename, $fileHeader.$text);

    if ($written == false) {
        throw new APIBuilderException("Failed to write file $filename.");
    }
}





class APIGenerator {

    /**
     * @var ClassGenerator
     */
    private $generator;
    
    private $interfaceGenerator;
    
    private $outputPath;
    private $namespace;
    private $parameterTranslations = [];

    private $apiParameters = [];
    
    private $delimiter = '#';
    

    /**
     * Fully qualified classname - aka namespace + classname
     * @var
     */
    private $fqcn;
    
    private $fqExceptionClassname = null;

    /**
     * @var string[] The interfaces the generated API class should implement
     */
    private $interfaces = [];
    
    private $interfaceName;
    

    private $includeMethods = [];

    private $excludeMethods = [];

    /**
     * @var callable
     */
    private $normalizeMethodCallable = null;

    /**
     * @var callable
     */
    private $normalizeClassCallable = null;

    /**
     * @var \ArtaxApiBuilder\OperationDefinition[]
     */
    private $operations = [];
    
    private $authErrorAsException = false;
    

    /**
     * @param $outputPath
     * @param $constructorParams
     */
    function __construct($outputPath, $constructorParams) {
        $this->generator = new ClassGenerator();
        $this->interfaceGenerator = new InterfaceGenerator(); 
        $this->constructorParams = $constructorParams;
        $this->addConstructorMethod();
        $this->outputPath = $outputPath;
    }


    /**
     * Whether to throw AuthException when an authorization error occurs.
     * 
     * The service can generate code to handle authorisation errors in one of two ways:
     *
     * i) Throw an AuthException.
     * ii) Retutn an AuthorisationRequiredResponse
     * 
     * @param $authErrorAsException
     */
    function setAuthErrorAsException($authErrorAsException) {
        $this->authErrorAsException = $authErrorAsException;
    }
    

    /**
     * Get the list of parameters (by name) that should only exist at an API level, rather
     * than being copied all over the API.
     * @return mixed
     */
    function getAPIParameters() {
        return $this->apiParameters;
    }

    /**
     * @return OperationDefinition[]
     */
    function getOperations() {
        return $this->operations;
    }

    /**
     * @param $interface
     */
    function addInterface($interface) {
        $this->interfaces[] = $interface;
    }

    /**
     * @param $parameter
     * @return mixed
     */
    function translateParameter($parameter) {
        if (array_key_exists($parameter, $this->parameterTranslations) == true) {
            return $this->parameterTranslations[$parameter];
        }

        return $parameter;
    }


    /**
     * @param $fqcn
     */
    function setFQCN($fqcn) {
        $this->fqcn = $fqcn;
        $this->generator->setFQCN($fqcn);

        if ($this->fqExceptionClassname == null) {
            $this->fqExceptionClassname =  $this->fqcn.'Exception';
        }

        $this->namespace = getNamespace($this->fqcn);
    }

    /**
     * 
     */
    function addConstructorMethod() {
        if (count($this->constructorParams)) {
            $methodGenerator = new MethodGenerator('__construct');

            $body = '';
            $params = [];
            foreach ($this->constructorParams as $constructorParam) {
                $param = new ParameterGenerator($constructorParam);
                $params[] = $param;
                $body .= sprintf('$this->%s = $%s;', $constructorParam, $constructorParam);
                $body .= PHP_EOL;
            }


            
            $param = new ParameterGenerator('oauthService', 'ArtaxApiBuilder\Service\Oauth1', null);

            $param->setDefaultValue(null);
            $params[] = $param;

            $body .= sprintf('$this->%s = $%s;', 'oauthService', 'oauthService');
            $body .= PHP_EOL;
            
            
            $methodGenerator->setBody($body);
            $methodGenerator->setParameters($params);
            $this->generator->addMethodFromGenerator($methodGenerator);
        }
    }
    

    /**
     *
     */
    function addCallMethod() {
        $methodGenerator = new MethodGenerator('callAPI');
        $requestParam = new ParameterGenerator('request', 'Artax\Request');
        $successStatusParam = new ParameterGenerator('successStatuses', 'array', []);
        $methodGenerator->setParameters([$requestParam, $successStatusParam]);
        $methodGenerator->setBody($this->getCallBody());
        $this->generator->addMethodFromGenerator($methodGenerator);
    }


    /**
     * 
     */
    function addSignMethod() {
        $methodGenerator = new MethodGenerator('signRequest');
        $requestParam = new ParameterGenerator('request', 'Artax\Request');
        $methodGenerator->setParameters([$requestParam]);
        
        $body = 'if ($this->oauthService == null) {'.PHP_EOL;;
        $body .= '    throw new \ArtaxApiBuilder\ArtaxServiceException("oauthService is null, so cannot call request that requires oauth.");'.PHP_EOL;;
        $body .= '}'.PHP_EOL;;

        $body .= 'return $this->oauthService->signRequest($request);'.PHP_EOL;
        $methodGenerator->setBody($body);
        $this->generator->addMethodFromGenerator($methodGenerator);
    }


    /**
     * 
     */
    function addPrepareMethod() {
        $methodGenerator = new MethodGenerator('prepareAPI');
        $methodGenerator->setParameters(['url', 'parameters']);
        $methodGenerator->setBody($this->getPrepareBody());
        $this->generator->addMethodFromGenerator($methodGenerator);
    }


    /**
     * @return string
     */
    function getPrepareBody() {

        $body = <<< 'END'

$client = new \Artax\Client();

$client->setOption('transfertimeout', 25);
$request = new \Artax\Request();
$fullURL = $url.'?'.http_build_query($parameters, '', '&', PHP_QUERY_RFC3986);
$request->setUri($fullURL);

return $request;
END;
        
        return $body;
    }
    
    
    /**
     * @return string
     */
    function getCallBody() {

//        $request = new \Artax\Request();
//        $fullURL = $url.'?'.http_build_query($parameters, '', '&', PHP_QUERY_RFC3986);
//        $request->setUri($fullURL);

        
        
        $body = <<< 'END'

$client = new \Artax\Client();

$client->setOption('transfertimeout', 25);

$response = $client->request($request);
$status = $response->getStatus();
$status = intval($status);

if ($successStatuses != null  && in_array($status, $successStatuses)) {
    throw new \%s(
        $response, 
        "Status does not match one of ".implode(', ', $successStatuses)
    );
}
else {
    if ($status < 200 || $status >= 300) {
        throw new \%s(
            $response, 
            "Status $status is not 20x success."
        );
    }
}

return $response;
END;
        $body = sprintf(
            $body,
            $this->fqExceptionClassname,
            $this->fqExceptionClassname
        );

        return $body;
    }


    /**
     * @param $methodName
     * @param $functionDefintion
     */
    function addMethod($methodName, OperationDefinition $operation) {
        $this->operations[$methodName] = $operation;
    }

    /**
     * Add the methods that return the operations in the API.
     */
    function addOperationGetters() {
        foreach ($this->operations as $methodName => $operation) {

            $operationName = $this->normalizeMethodName($methodName);
            $operationClassName = $this->normalizeClassName($methodName);
            $methodGenerator = new MethodGenerator($operationName);
            
            //All required parameters must be passed in when the operation is created.
            $requiredParameters = $operation->getRequiredParams();
            $paramsStrings = [];
            $requiredParamsStringsWithDollar = [];
            foreach($requiredParameters as $requiredParam) {
                $paramsStrings[] = $requiredParam->getName();
                //TODO - replace with array_map on $paramsStrings
                $requiredParamsStringsWithDollar[] = '$'.$requiredParam->getName();
            }

            $paramString = implode(', ', $requiredParamsStringsWithDollar);
            $methodGenerator->setParameters($paramsStrings);

            //Parameters which are set at the API level need to be passed into the
            //operation from the API
            $tags = [];
            $apiParameters = $this->getAPIParameters();
            foreach ($requiredParameters as $param) {
                if (in_array($param->getName(), $apiParameters) == true) {
                    $paramsStrings[] = $param->getName();
                }
                //TODO - allow type defining to work, rather than just mixed.
                $tags[] = new GenericTag('param', ''.$param->getName().' mixed '.$param->getDescription());
            }

            $body = "\$instance = new $operationClassName($paramString);".PHP_EOL;
            $body .= "\$instance->setAPI(\$this);".PHP_EOL;
            $body .= "return \$instance;".PHP_EOL;

            
            $docBlockGenerator = new DocBlockGenerator($methodName);
            $docBlockGenerator->setLongDescription($operation->getSummary());
            $docBlockGenerator->setTags($tags);

            $methodGenerator->setDocBlock($docBlockGenerator);
            $methodGenerator->setBody($body);
            $this->generator->addMethodFromGenerator($methodGenerator);
            $this->interfaceGenerator->addMethodFromGenerator($methodGenerator);
        }
    }

    /**
     * 
     */
    private function generateMethods() {
        foreach ($this->operations as $methodName => $operation) {
            $this->generateOperationClass($methodName, $operation);
        }
    }

    /**
     * @param $methodName
     * @return mixed
     */
    public function normalizeMethodName($methodName) {
        if ($this->normalizeMethodCallable != null) {
            $callable = $this->normalizeMethodCallable;
            return $callable($methodName);
        }

        $pattern = '/\.(\w?)/i';

        $replaceCallable = function (array $matches) {
            return strtoupper($matches[1]);
        };

        return preg_replace_callback($pattern, $replaceCallable, $methodName);
    }

    /**
     * @param $methodName
     * @return mixed
     */
    public function normalizeClassName($methodName) {
        if ($this->normalizeClassCallable != null) {
            $callable = $this->normalizeClassCallable;
            return $callable($methodName);
        }

        $pattern = '/\.(\w?)/i';

        $replaceCallable = function (array $matches) {
            return strtoupper($matches[1]);
        };

        return preg_replace_callback($pattern, $replaceCallable, $methodName);
    }

    /**
     * @param $methodName
     * @param OperationDefinition $operation
     */
    private function generateOperationClass($methodName, OperationDefinition $operation) {
        $className = $this->normalizeClassName($methodName);
        
        $operationGenerator = new OperationGenerator(
            $this->namespace,
            $className,
            $operation,
            $this->outputPath,
            $this
        );

        $operationGenerator->setAPIClassname($this->fqcn);
        
        $operationGenerator->generate();
    }


    /**
     * @param $interfaceFQCN
     * @throws APIBuilderException
     */
    function generateInterface($interfaceFQCN) {
        $this->interfaceGenerator->setFQCN($interfaceFQCN);
        $text = $this->interfaceGenerator->generate();
        saveFile($this->outputPath, $interfaceFQCN, $text);
    }

    /**
     * @throws \Exception
     */
    function sanityCheck() {

        if (!$this->fqcn) {
            throw new APIBuilderException("fqcn is empty, cannot generate API.");
        }

        if (!$this->fqExceptionClassname) {
            throw new APIBuilderException("fqExceptionClassname is empty, cannot generate API.");
        }
    }


    /**
     * @throws \ArtaxApiBuilder\APIBuilderException
     */
    function generateExceptionClass() {
        
        $namespace = getNamespace($this->fqcn);
        $classname = getClassName($this->fqcn);
        $exceptionClassname = $classname.'Exception';

        if ($namespace) {
            $fqExceptionClassname = $namespace.'\\'.$classname.'Exception';
        }
        else {
            $fqExceptionClassname = $classname.'Exception';
        }

$classText = <<< END

namespace $namespace;

use Artax\Response;

class $exceptionClassname extends \Exception {

    /**
     * @var \Artax\Response
     */
    private \$response;
    
    function __construct(Response \$response, \$message = "", \$code = 0, \Exception \$previous = null) {
        parent::__construct(\$message, \$code, \$previous);
        \$this->response = \$response;
    }
    
    function getResponse() {
        return \$this->response;
    }
}

END;

        saveFile($this->outputPath, $fqExceptionClassname, $classText);
    }

    /**
     * @param array $methodNameArray
     */
    function includeMethods(array $methodNameArray) {
        $quoteCallable = function ($string) {
            return preg_quote($string, $this->delimiter);
        };
        $newIncludes = array_map($quoteCallable, $methodNameArray);
        $this->includeMethods = array_merge($this->includeMethods, $newIncludes);
    }

    /**
     * @param array $methodNameArray
     */
    function excludeMethods(array $methodNameArray) {
        $quoteCallable = function ($string) {
            return preg_quote($string, $this->delimiter);
        };
        $newExcludes = array_map($quoteCallable, $methodNameArray);
        $this->excludeMethods = array_merge($this->excludeMethods, $newExcludes);
    }
    
    
    /**
     * @param $pattern
     */
    function includePattern($pattern) {
        $this->includeMethods[] = $pattern;
    }


    /**
     * @param $pattern
     */
    function excludePattern($pattern) {
        $this->excludeMethods[] = $pattern;
    }



    /**
     * @param $operationName
     * @return bool
     */
    function shouldOperationBeGenerated($operationName) {
        
        $shouldInclude = false;
        
        if (count($this->includeMethods) == 0) {
            //Include filter is empty - so add all operations.
            $shouldInclude = true;
        }
        
        foreach ($this->includeMethods as $includePattern) {
            $includePattern = $this->delimiter.$includePattern.$this->delimiter;
            if (preg_match($includePattern, $operationName)) {
                $shouldInclude = true;
            }
        }

        foreach ($this->excludeMethods as $excludePattern) {
            $includePattern = $this->delimiter.$excludePattern.$this->delimiter;
            if (preg_match($includePattern, $operationName)) {
                $shouldInclude = false;
            }
        }
        

        return $shouldInclude;
    }

    /**
     * Guzzle style service descriptions have a bad habit of requiring certain parameters
     * that ought to be defined once, be defined in every operation that requires them. 
     * For example the Flickr API requires the api_key be set for every operation. It dumb 
     * and counter-productive to define this repeatedly in the API. It should be set once
     * in the API, and that value be passed to every operation that requires it.
     * @param array $apiParameters
     */
    public function addAPIParameters(array $apiParameters) {
        $this->apiParameters = array_merge($this->apiParameters, $apiParameters);
    }

    public function addAPIParameter($name, $type = null) {
        $this->apiParameters[$name] = $type;
    }
    

    /**
     * Allows you to use your preference for formatting of variables in the API library
     * code, while still passing the correct variables to the API end-point.
     * 
     * Because other people have no taste.
     * @param array $translations
     */
    public function addParameterTranslation(array $translations) {
        $this->parameterTranslations = array_merge($this->parameterTranslations, $translations);
    }
    

    /**
     * @param $service
     * @param $operationName
     * @param $baseURL
     * @return OperationDefinition
     * @throws \ArtaxApiBuilder\APIBuilderException
     */
    function createOperationDescription($service, $operationName, $baseURL) {

        if (isset($service["operations"][$operationName]) == false) {
            throw new APIBuilderException("Service does not have operation named `$operationName`.");
        }

        $operationDescription = $service["operations"][$operationName];

        if (isset($operationDescription['extends'])) {
            $operation = $this->createOperationDescription($service, $operationDescription['extends'], $baseURL);
        }
        else {
            $operation = new OperationDefinition();
        }

        $operation->setName($operationName);
        $operation->setURL($baseURL);//Do this first, as it can be overwritten
        $operation->setFromServiceDescription($operationDescription, $this);

        return $operation;
    }


    /**
     * @param $serviceFilename
     * @return array
     * @throws APIBuilderException
     */
    function parseAndAddServiceFromFile($serviceFilename) {
        $service = require_once($serviceFilename);

        if ($service == false) {
            throw new APIBuilderException("Failed to open service file `$serviceFilename`.");
        }
        if (is_array($service) == false) {
            throw new APIBuilderException("File `$serviceFilename` did not return a service array. Cannot build API from it.");
        }

        $this->parseAndAddService($service);
    }

    /**
     * @param array $service
     * @throws APIBuilderException
     */
    function parseAndAddService(array $service) {

        $baseURL = null;

        if (isset($service["baseUrl"])) {
            $baseURL = $service["baseUrl"];
        }

        foreach ($service["operations"] as $operationName => $operationDescription) {
            if ($this->shouldOperationBeGenerated($operationName)) {
                $operation = $this->createOperationDescription($service, $operationName, $baseURL);
                $this->addMethod($operation->getName(), $operation);
            }
        }
    }


    /**
     * 
     */
    function addAPIParameterAccessMethod() {

        foreach ($this->apiParameters as $apiParameter => $type) {
            $translatedParam = ucfirst($this->translateParameter($apiParameter));
            
            $methodGenerator = new MethodGenerator('get'.$translatedParam);
            $body = 'return $this->'.$apiParameter.';'.PHP_EOL;
            $methodGenerator->setBody($body);
            
            $methodGenerator->setDocBlock("@return $type");
            
            $this->generator->addMethodFromGenerator($methodGenerator);

            $methodGenerator = new MethodGenerator('set'.$translatedParam);
            $body = '$this->'.$apiParameter.' = $value;'.PHP_EOL;
            $parameterParameter = new ParameterGenerator('value');
            $methodGenerator->setParameter($parameterParameter);
            $methodGenerator->setBody($body);
            $this->generator->addMethodFromGenerator($methodGenerator);
        }
    }

    /**
     * 
     */
    private function addProperties() {
        $this->apiParameters;
        $nativeProperties = ['oauthService' => 'ArtaxApiBuilder\Service\Oauth1'];
        $allProperties = [$this->apiParameters, $nativeProperties];

        foreach ($allProperties as $properties) {
            foreach ($properties as $property => $type) {
                $propGenerator = new PropertyGenerator($property);
                
//                $docBlockGenerator = new DocBlockGenerator();
//                $docBlockGenerator->setTag(new GenericTag())

                $propGenerator->setStandardDocBlock($type);
                $this->generator->addPropertyFromGenerator($propGenerator);
            }
        }
    }

    /**
     *
     */
    function generate() {        
        $this->sanityCheck();
        $this->addProperties();
        $this->addSignMethod();
        $this->addCallMethod();
        $this->generateMethods();
        $this->addAPIParameterAccessMethod();
        $this->addOperationGetters();

        if (count($this->interfaces)) {
            $this->generator->setImplementedInterfaces($this->interfaces);
        }

        $this->generateExceptionClass();

        $text = $this->generator->generate();
        saveFile($this->outputPath, $this->fqcn, $text);
    }
}